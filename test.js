// Generated by CoffeeScript 2.2.2
(function() {
  var AWS, AWSmock, DynamoUtil, Util, _, cache, config, https, metrics;

  _ = require('underscore');

  cache = require('memory-cache');

  https = require('https');

  AWS = require('aws-sdk');

  if (process.env.ENV === 'test') {
    AWSmock = require('aws-sdk-mock');
    AWSmock.mock('DynamoDB', 'putItem', function(params, callback) {
      cache.put('dynamoMock-' + params.Item._id.S, params);
      return callback(null, 'successfully put item in database');
    });
    AWSmock.mock('DynamoDB', 'getItem', function(params, callback) {
      return callback(null, cache.get('dynamoMock-' + params.Key._id.S));
    });
  }

  Util = require('../utils/util');

  metrics = require('../utils/metrics');

  config = require('../utils/configurator');

  DynamoUtil = (function() {
    class DynamoUtil {
      constructor() {
        var ref, ref1, ref2;
        this.cluster = new AWS.DynamoDB({
          accessKeyId: ((ref = config.AWS_ACCESS_KEY_ID) != null ? ref.length : void 0) ? config.AWS_ACCESS_KEY_ID : void 0,
          secretAccessKey: ((ref1 = config.AWS_SECRET_ACCESS_KEY) != null ? ref1.length : void 0) ? config.AWS_SECRET_ACCESS_KEY : void 0,
          region: ((ref2 = config.AWS_REGION) != null ? ref2.length : void 0) ? config.AWS_REGION : void 0,
          apiVersion: '2012-08-10',
          httpOptions: {
            agent: new https.Agent({
              rejectUnauthorized: true,
              keepAlive: true
            })
          }
        });
        this.flush();
      }

      flush() {
        return cache.clear();
      }

      get(method, params, opts, cb) {
        var _compute_get, bucket, callback, init_time, key, result;
        ({bucket, key, opts, callback} = this._params(method, params, opts, cb));
        delete opts.expiry;
        init_time = Date.now();
        _compute_get = (err, res) => {
          var allow, cache_item, calculate_automat, deny, targeting;
          metrics.save(`dynamo.${bucket}.get`, Date.now() - init_time);
          if (err != null) {
            this._error(method, "get", key, opts);
          }
          // Put the result into the cache
          if (err == null) {
            if (opts.cache && opts.cache.type === 'global') {
              cache_item = res != null ? res : -1;
              // ###########################################
              // Temporary optim for checking geo targeting
              // ###########################################
              if (key.startsWith('cm:') && typeof cache_item === 'object' && (cache_item['value']['geo_targeting'] != null)) {
                cache_item['value']['geo_automat'] = {};
                if (cache_item['value']['geo_targeting'].length === 0) {
                  cache_item['value']['geo_automat']['allow'] = true;
                } else {
                  targeting = cache_item['value']['geo_targeting'].toLowerCase().split(',');
                  allow = _(targeting).filter(function(t) {
                    return t.substr(0, 5) === 'allow';
                  }).map(function(t) {
                    return t.slice(6).split(':');
                  });
                  deny = _(targeting).filter(function(t) {
                    return t.substr(0, 4) === 'deny';
                  }).map(function(t) {
                    return t.slice(5).split(':');
                  });
                  calculate_automat = function(target) {
                    var a, automat, i, len;
                    automat = null;
                    for (i = 0, len = target.length; i < len; i++) {
                      a = target[i];
                      if (automat == null) {
                        automat = a[0] === 'all' ? true : {};
                      }
                      if (a[0] === 'all') {
                        continue;
                      }
                      if (automat[a[0]] == null) {
                        automat[a[0]] = a[1] === 'all' ? true : {};
                      }
                      if (a[1] === 'all' || automat[a[0]] === true) {
                        continue;
                      }
                      if (automat[a[0]][a[1]] == null) {
                        automat[a[0]][a[1]] = a[2] === 'all' ? true : {};
                      }
                      if (a[2] === 'all' || automat[a[0]][a[1]] === true) {
                        continue;
                      }
                      automat[a[0]][a[1]][a[2]] = true;
                    }
                    return automat;
                  };
                  cache_item['value']['geo_automat']['allow'] = calculate_automat(allow);
                  cache_item['value']['geo_automat']['deny'] = calculate_automat(deny);
                }
              }
              // ###########################################
              cache.put(`dynamo-${key}`, cache_item, opts.cache.expiry);
            }
          }
          return callback(err, res);
        };
        params = {
          Key: {
            '_id': {
              S: key
            }
          },
          TableName: bucket,
          ProjectionExpression: '#value',
          ExpressionAttributeNames: {
            '#value': 'value'
          }
        };
        // Try to get value from cache
        if (opts.cache && opts.cache.type === 'global') {
          result = cache.get(`dynamo-${key}`);
          if (result) {
            return callback(null, result === -1 ? null : result);
          } else {
            return this.cluster.getItem(params, _compute_get);
          }
        } else {
          return this.cluster.getItem(params, _compute_get);
        }
      }

      //  del: (method, params, opts, cb) ->
      //    { bucket, key, opts, callback } = @_params method, params, opts, cb
      //    bucket.remove key, opts, (err, res) =>
      //      @_error method, "del", key, opts if err? and err.code is not 13

      //      # Remove the stored value in the cache
      //      if !err and opts.cache and opts.cache.type is 'global'
      //        cache.del "dynamo-#{key}"

      //      callback err, res
      set(method, params, value, opts, cb) {
        var bucket, callback, key;
        if (typeof opts === 'function') {
          cb = opts;
          opts = {};
        }
        ({bucket, key, opts, callback} = this._params(method, params, opts, cb));
        params = {
          Item: {
            '_id': {
              S: key
            },
            'value': {
              S: JSON.stringify(value)
            }
          },
          TableName: bucket
        };
        return this.cluster.putItem(params, (err, res) => {
          if (err != null) {
            this._error(method, "set", key, opts, value);
          }
          return callback(err, res);
        });
      }

      //  incr: (method, params, optional..., cb) ->
      //    # optional = [[value]]
      //    { bucket, key, opts, callback } = @_params method, params, null, cb

      //    value = if optional.length > 0 then optional[0] else 1
      //    if value?
      //      opts.initial = value

      //    bucket.counter key, value, opts, (err, res) =>
      //      @_error method, "incr", key, opts if err? and err.code is not 13
      //      callback err, res
      _error(ogury_method, method, key, opts, err, value = "") {
        return console.error("Dynamo Error: met=%s, op=%s, k=%s, opt=%j, val=%j, err=%j", ogury_method, method, key, opts, value, err);
      }

      keys() {
        if (!this._keys) {
          this._keys = require('../utils/keys');
        }
        return this._keys;
      }

      _wrap(callback) {
        callback = Util.resolveFunc(callback);
        return function(err, results) {
          var ref, ref1;
          if (err) {
            return callback(err, null);
          } else {
            if ((results != null ? (ref = results.Item) != null ? (ref1 = ref.value) != null ? ref1.S : void 0 : void 0 : void 0) != null) {
              return callback(null, JSON.parse(results.Item.value.S));
            } else {
              return callback(null, null);
            }
          }
        };
      }

      _resolveMethod(method) {
        method = method.charAt(0).toUpperCase() + method.slice(1);
        return `for${method}`;
      }

      _params(keyMethod, keyParams, options, callback) {
        var bucket, env, key, opts;
        keyMethod = this._resolveMethod(keyMethod);
        if (!this.keys()[keyMethod]) {
          throw new Error(`${keyMethod} isn't defined in Keys`);
        }
        ({bucket, key, opts} = this.keys()[keyMethod].apply(this, keyParams));
        env = process.env.ENV === 'production' ? 'prod' : process.env.ENV;
        bucket = bucket + '-' + env;
        if (!options) {
          options = {};
        }
        if (typeof options === 'function') {
          callback = options;
          options = {};
        }
        opts = _.extend(opts, options);
        callback = this._wrap(callback);
        return {bucket, key, opts, callback};
      }

    };

    DynamoUtil.prototype._keys = null;

    return DynamoUtil;

  }).call(this);

  module.exports = new DynamoUtil();

}).call(this);
